This file has examples  of the foundations of leetcode problems, and serves as algorithmic foundation to answer different questions. 

1. Hashmaps
2. Recursion
3. DFS & BFS
4. Binary Search
5. Sliding Window
6. Heaps

Data Structures: 
Arrays, linked lists, stacks, queues
Trees (binary trees, AVL trees, red-black trees)
Heaps and priority queues
Hash tables
Graphs (adjacency lists, adjacency matrices)

Sorting and Searching Algorithms:
Quick sort, merge sort, heap sort
Binary search, depth-first search (DFS), breadth-first search (BFS)

Dynamic Programming:
Principles and common patterns (e.g., memoization, tabulation)
Classic problems (e.g., knapsack problem, longest common subsequence)

Graph Algorithms:
Shortest path algorithms (Dijkstra's, Bellman-Ford)
Minimum spanning tree (Kruskal's, Prim's)
Network flow algorithms (Ford-Fulkerson, Edmonds-Karp)

Greedy Algorithms:
Techniques and classic problems (e.g., Huffman coding, activity selection)

Advanced Algorithmic Techniques:
Backtracking (e.g., N-Queens problem)
Divide and conquer (e.g., merge sort, quicksort)
Randomized algorithms (e.g., randomized quicksort, Monte Carlo methods)

Additional Lessons and Skills:
Algorithmic Analysis:
Time Complexity:

Understanding Big O notation to evaluate the efficiency of algorithms.
Analyzing worst-case, best-case, and average-case complexities.
Identifying and optimizing bottlenecks in algorithms.
Space Complexity:

Assessing memory usage and optimizing space requirements.
Understanding auxiliary space vs. input space.
Problem-Solving Strategies:
Breaking Down Problems:

Decomposing complex problems into smaller, manageable sub-problems.
Using systematic approaches like divide and conquer, dynamic programming, and greedy methods.
Edge Case Handling:

Identifying and addressing edge cases to ensure robust solutions.
Writing comprehensive test cases to validate solutions against various scenarios.

Coding Skills:
Code Readability and Maintainability:

Writing clean, readable code with proper comments and variable naming conventions.
Structuring code for easy maintenance and scalability.
Debugging Techniques:

Using print statements, logging, and debugging tools to identify and fix issues.
Analyzing runtime errors and logical errors effectively.
Optimization Techniques:
Memoization and Caching:

Implementing memoization to store results of expensive function calls.
Using caching techniques to speed up repeated computations.
Parallel and Concurrent Programming:

Understanding the basics of parallelism and concurrency.
Writing algorithms that leverage multi-threading and parallel processing for performance gains.
Mathematical Foundations:
Combinatorics and Probability:

Applying combinatorial techniques to solve counting problems.
Using probability theory to address problems involving randomness and statistical inference.
Number Theory:

Utilizing concepts like prime factorization, greatest common divisors, and modular arithmetic in algorithms.

Further Reading and Practice:
