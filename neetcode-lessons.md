# Foundations of LeetCode Problems

This document provides examples of foundational concepts and techniques essential for solving various types of LeetCode problems. It serves as an algorithmic foundation to answer different questions effectively.

## Key Algorithmic Concepts

### 1. Hashmaps
![Hashmaps](https://upload.wikimedia.org/wikipedia/commons/5/5a/Hash_table_5_0_1_1_1_1_1_LL.svg)
**My understanding:** ⭐ / 5

### 2. Recursion
![Recursion](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7a/Recursion-tree-of-factorial-function.png/800px-Recursion-tree-of-factorial-function.png)
**My understanding:** ⭐⭐⭐ / 5

### 3. Depth-First Search (DFS) & Breadth-First Search (BFS)
![DFS & BFS](https://upload.wikimedia.org/wikipedia/commons/1/1f/Depth-first-tree.svg)
**My understanding:** ⭐⭐⭐ / 5

### 4. Binary Search
![Binary Search](https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_search_into_array.png)
**My understanding:** ⭐ / 5

### 5. Sliding Window
![Sliding Window](https://miro.medium.com/max/1400/1*57MYBEhbqA9VtZ-2O5gmOg.gif)
**My understanding:**  / 5

### 6. Heaps
![Heaps](https://upload.wikimedia.org/wikipedia/commons/thumb/3/38/Max-Heap.svg/1200px-Max-Heap.svg.png)
**My understanding:** ⭐ / 5

## Data Structures

### Arrays
![Arrays](https://upload.wikimedia.org/wikipedia/commons/d/d7/Array1.jpg)
**My understanding:** ⭐⭐⭐ / 5

### Linked Lists
![Linked Lists](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg)
**My understanding:** ⭐⭐ / 5

### Stacks
![Stacks](https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/1200px-Data_stack.svg.png)
**My understanding:** ⭐⭐⭐ / 5

### Queues
![Queues](https://upload.wikimedia.org/wikipedia/commons/5/52/Data_Queue.svg)
**My understanding:** ⭐⭐ / 5

### Trees (Binary Trees, AVL Trees, Red-Black Trees)
![Binary Trees](https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_tree.svg)
**My understanding:** ⭐ / 5

### Heaps and Priority Queues
![Heaps and Priority Queues](https://upload.wikimedia.org/wikipedia/commons/thumb/1/12/Heap.PUSH.svg/2560px-Heap.PUSH.svg.png)
**My understanding:** ⭐ / 5

### Hash Tables
![Hash Tables](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7d/Hash_table_5_0_1_1_0_1_0_LL.svg/2560px-Hash_table_5_0_1_1_0_1_0_LL.svg.png)
**My understanding:** ⭐ / 5

### Graphs (Adjacency Lists, Adjacency Matrices)
![Graphs](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/6n-graf.svg/1024px-6n-graf.svg.png)
**My understanding:** ⭐⭐/ 5

## Sorting and Searching Algorithms

### Quick Sort
![Quick Sort](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)
**My understanding:** ⭐ / 5

### Merge Sort
![Merge Sort](https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif)
**My understanding:**  / 5

### Heap Sort
![Heap Sort](https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif)
**My understanding:**  / 5

### Binary Search
![Binary Search](https://upload.wikimedia.org/wikipedia/commons/8/83/Binary_search_algorithm_diagram.svg)
**My understanding:** ⭐ / 5

### Depth-First Search (DFS)
![DFS](https://upload.wikimedia.org/wikipedia/commons/1/1f/Depth-first-tree.svg)
**My understanding:** ⭐ / 5

### Breadth-First Search (BFS)
![BFS](https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif)
**My understanding:** ⭐ / 5

## Dynamic Programming

### Principles and Common Patterns
![Dynamic Programming](https://miro.medium.com/max/1400/1*lhzVTxvB0Cd1ER-0ox4I8w.gif)
**My understanding:** ⭐⭐ / 5

### Classic Problems (Knapsack Problem, Longest Common Subsequence)
![Knapsack Problem](https://upload.wikimedia.org/wikipedia/commons/f/fd/Knapsack.svg)
**My understanding:** ⭐⭐⭐⭐⭐ / 5

## Graph Algorithms

### Shortest Path Algorithms (Dijkstra's, Bellman-Ford)
![Shortest Path Algorithms](https://upload.wikimedia.org/wikipedia/commons/thumb/5/57/Dijkstra_Animation.gif/220px-Dijkstra_Animation.gif)
**My understanding:** ⭐⭐⭐/ 5

### Minimum Spanning Tree (Kruskal's, Prim's)
![Minimum Spanning Tree](https://upload.wikimedia.org/wikipedia/commons/d/d2/Minimum_spanning_tree.svg)
**My understanding:** ⭐⭐ / 5

### Network Flow Algorithms (Ford-Fulkerson, Edmonds-Karp)
![Network Flow Algorithms](https://upload.wikimedia.org/wikipedia/commons/8/86/Max_flow_min_cut_theorem.svg)
**My understanding:** ⭐⭐⭐⭐⭐ / 5

## Greedy Algorithms

### Techniques and Classic Problems (Huffman Coding, Activity Selection)
![Greedy Algorithms](https://upload.wikimedia.org/wikipedia/commons/2/23/Huffman_coding_visualisation.svg)
**My understanding:** ⭐ / 5

## Advanced Algorithmic Techniques

### Backtracking (N-Queens Problem)
![Backtracking](https://upload.wikimedia.org/wikipedia/commons/e/e7/Backtracking.svg)
**My understanding:** ⭐/ 5

### Divide and Conquer (Merge Sort, Quicksort)
![Divide and Conquer](https://upload.wikimedia.org/wikipedia/commons/e/e6/Divide-and-Conquer


### Randomized Algorithms (Randomized Quicksort, Monte Carlo Methods)
![Randomized Algorithms](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/Quicksort-diagram.svg/1200px-Quicksort-diagram.svg.png)
**My understanding:**  / 5

## Additional Lessons and Skills

### Algorithmic Analysis

- **Time Complexity**:
  ![Time Complexity](https://upload.wikimedia.org/wikipedia/commons/thumb/5/52/Big-O_complexity.svg/1200px-Big-O_complexity.svg.png)
  **My understanding:** ⭐⭐⭐⭐ / 5
  - Understanding Big O notation to evaluate the efficiency of algorithms.
  - Analyzing worst-case, best-case, and average-case complexities.
  - Identifying and optimizing bottlenecks in algorithms.

- **Space Complexity**:
  ![Space Complexity](https://upload.wikimedia.org/wikipedia/commons/9/99/Algorithm_Complexity.png)
  **My understanding:** ⭐ / 5
  - Assessing memory usage and optimizing space requirements.
  - Understanding auxiliary space vs. input space.

### Problem-Solving Strategies

- **Breaking Down Problems**:
  ![Breaking Down Problems](https://miro.medium.com/max/1400/1*vSNusfYxyf4NYe15u8mAIQ.png)
  **My understanding:** ⭐⭐ / 5
  - Decomposing complex problems into smaller, manageable sub-problems.
  - Using systematic approaches like divide and conquer, dynamic programming, and greedy methods.

- **Edge Case Handling**:
  ![Edge Case Handling](https://miro.medium.com/max/1000/0*vRGwwfGSeDr5g2rF)
  **My understanding:** ⭐ / 5
  - Identifying and addressing edge cases to ensure robust solutions.
  - Writing comprehensive test cases to validate solutions against various scenarios.

### Coding Skills

- **Code Readability and Maintainability**:
  ![Code Readability](https://miro.medium.com/max/1400/1*_n0G0I3qHkhWCE9t0zE70g.png)
  **My understanding:** ⭐⭐⭐ / 5
  - Writing clean, readable code with proper comments and variable naming conventions.
  - Structuring code for easy maintenance and scalability.

- **Debugging Techniques**:
  ![Debugging Techniques](https://miro.medium.com/max/1024/1*VtJRHbnsEdQ75-YR4S0DTg.png)
  **My understanding:** ⭐⭐⭐ / 5
  - Using print statements, logging, and comments to identify bugs and solutions.
